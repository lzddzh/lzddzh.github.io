---
title: 'Leetcode 133. Clone Graph
'
layout: post
tags:
  - leetcode
  - contest
  - C++
  - medium
category: Algorithms 
---

Copy a graph.

<!--more-->

## Description

Clone an undirected graph. Each node in the graph contains a label and a list of its neighbors.


OJ's undirected graph serialization:
Nodes are labeled uniquely.

We use # as a separator for each node, and , as a separator for node label and each neighbor of the node.
As an example, consider the serialized graph {0,1,2#1,2#2,2}.

The graph has a total of three nodes, and therefore contains three parts as separated by #.

1. First node is labeled as 0. Connect node 0 to both nodes 1 and 2.
2. Second node is labeled as 1. Connect node 1 to node 2.
3. Third node is labeled as 2. Connect node 2 to node 2 (itself), thus forming a self-cycle.
Visually, the graph looks like the following:

```
       1
      / \
     /   \
    0 --- 2
         / \
         \_/
```

## Complexity Analysis
O(n * k) , where n is the number of nodes and k is the average degree of nodes.

## Code

**My Code**:

```cpp
/**
 * Definition for undirected graph.
 * struct UndirectedGraphNode {
 *     int label;
 *     vector<UndirectedGraphNode *> neighbors;
 *     UndirectedGraphNode(int x) : label(x) {};
 * };
 */
class Solution {
public:
    UndirectedGraphNode *cloneGraph(UndirectedGraphNode *node) {
        if (node == NULL) return node;
        unordered_set<UndirectedGraphNode*> visited;
        UndirectedGraphNode *newNode = new UndirectedGraphNode(node->label);
        dfs(node, newNode, visited);
        return newNode;
    }
    void dfs(UndirectedGraphNode *node, UndirectedGraphNode *p, unordered_set<UndirectedGraphNode*> &visited) {
        auto it = visited.find(node);
        if (it != visited.end()) return;
        p->label = node->label;
        visited.insert(node);
        mp[node] = p;
        for (int i = 0; i < node->neighbors.size(); i++) {
            if (mp.find(node->neighbors[i]) != mp.end()) {
                p->neighbors.push_back(mp[node->neighbors[i]]);
            } else {
                UndirectedGraphNode *t = new UndirectedGraphNode(node->label);;
                p->neighbors.push_back(t);
                dfs(node->neighbors[i], t, visited);
            }
        }
    }
private:
    // The key line of the solution. 
    // Why use this:
    // Think about below cases:
    /* Case 1:
         0 -> 0
       Case 2:
         1 -> 2, 2 -> 1
    */
    // In fact it is actually a directed graph.
    unordered_map<UndirectedGraphNode*, UndirectedGraphNode*> mp;
};
```


**Perfect code**:

```cpp
// DFS
class Solution {
public:
    UndirectedGraphNode *cloneGraph(UndirectedGraphNode *node) {
        if (!node) return NULL;
        if (mp.find(node) == mp.end()) {
            mp[node] = new UndirectedGraphNode(node -> label);
            for (UndirectedGraphNode* neigh : node -> neighbors)
                mp[node] -> neighbors.push_back(cloneGraph(neigh));
        }
        return mp[node];
    } 
private:
    unordered_map<UndirectedGraphNode*, UndirectedGraphNode*> mp;
};
```
	
## Useful code

using `unordered_map<node*, node*>` for node to node graph copy.